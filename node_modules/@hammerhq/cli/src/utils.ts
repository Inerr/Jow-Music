// TODO: Use @hammerhq/logger (hammer_modules) when cli finished
import * as pogger from "pogger";
import AdmZip from "adm-zip";
import chalk from "chalk";
import {
	createWriteStream,
	existsSync,
	mkdirSync,
	readdirSync,
	rmSync,
	statSync,
	writeFileSync,
} from "fs";
import mv from "mv";
import { join } from "path";
import readline from "readline";
import { Stream } from "stream";
import axios from "axios";
import { parse } from "@iarna/toml";
import { Octokit } from "octokit";

export const octokit = new Octokit();

export const createDeclarationFile = () => {
	if (!checkIfProjectExists()) return;
	createModulesFolder();

	const modules: string[] = [];

	const authors = readdirSync(join(process.cwd(), "hammer_modules"));
	if (authors.length) {
		for (const author of authors) {
			const repos = readdirSync(
				join(process.cwd(), "hammer_modules", author),
			);
			if (repos.length) {
				for (const repo of repos) {
					if (
						existsSync(
							join(
								process.cwd(),
								"hammer_modules",
								author,
								repo,
								"hammer.toml",
							),
						)
					)
						modules.push(`${author}/${repo}`);
				}
			}
		}
	}

	const typingsFile = `export declare const include: <T extends ModuleName>(module: string) => IncludeType<T>;

export type ModuleName = ${
		modules.length
			? modules.map((module) => `"${module}"`).join(" | ")
			: "never"
	};

export type IncludeType<T> = 
    ${
		modules.length
			? `${modules
					.map(
						(module) =>
							`T extends "${module}" ? typeof import(${JSON.stringify(
								join(
									process.cwd(),
									"hammer_modules",
									module,
									"hammer",
									"main",
								),
							)})`,
					)
					.join(" | ")} : never`
			: "never"
	}
`;

	writeFileSync(join(__dirname, "index.d.ts"), typingsFile);
};

export function input(query: string): Promise<string> {
	const rl = readline.createInterface({
		input: process.stdin,
		output: process.stdout,
	});

	return new Promise((resolve) =>
		rl.question(
			`${pogger.utils.generateDate()} ${
				pogger.utils.icons.logIcon
			} [HAMMER]: ${query} `,
			(ans: string) => {
				rl.close();
				resolve(ans);
			},
		),
	);
}

export function waitUntilGetAnswer(query: string): Promise<string> {
	return new Promise<string>(async (resolve) => {
		let answer = "";
		while (!answer) {
			answer = await input(query);
		}
		resolve(answer);
	});
}

export function checkIfProjectExists() {
	const isExists = existsSync(join(process.cwd(), "hammer.toml"));
	if (isExists) {
		return true;
	}
	pogger.error(
		`There is no Hammer project here. ${chalk.green(
			"Create a Hammer project",
		)} using ${chalk.yellow("hammer init")} command.`,
	);
	return false;
}

export function createModuleFolder(module: string) {
	let mkdir = true;
	if (existsSync(join(process.cwd(), "hammer_modules", module))) {
		const stats = statSync(join(process.cwd(), "hammer_modules", module));
		if (stats.isDirectory()) mkdir = false;
	}
	if (mkdir) mkdirSync(join(process.cwd(), "hammer_modules", module));
}

export function createModulesFolder() {
	let mkdir = true;
	if (existsSync(join(process.cwd(), "hammer_modules"))) {
		const stats = statSync(join(process.cwd(), "hammer_modules"));
		if (stats.isDirectory()) mkdir = false;
	}
	if (mkdir) mkdirSync(join(process.cwd(), "hammer_modules"));
}

export function createMainFile() {
	let mkdir = true;
	if (existsSync(join(process.cwd(), "hammer"))) {
		const stats = statSync(join(process.cwd(), "hammer"));
		if (stats.isDirectory()) mkdir = false;
	}
	if (mkdir) mkdirSync(join(process.cwd(), "hammer"));

	let write = true;
	if (existsSync(join(process.cwd(), "hammer", "main.js"))) {
		const stats = statSync(join(process.cwd(), "hammer", "main.js"));
		if (stats.isFile()) write = false;
	}
	if (write)
		writeFileSync(
			join(process.cwd(), "hammer", "main.js"),
			"module.exports.test = () => console.log('test');",
		);
}

export async function installPackage(
	pkg: string,
	dependencies: string[],
	nodeDepencencies: string[],
	packages: string[],
) {
	pogger.info(`Installing ${chalk.yellow(pkg)}...`);

	const [owner, repo] = pkg.split("/");
	if (!owner || !repo) {
		pogger.error(`Invalid package name: ${chalk.yellow(pkg)}`);
		return;
	}

	const repoRes = await octokit.rest.repos.get({
		repo,
		owner,
	});
	if (repoRes.status != 200) {
		pogger.error(
			`Invalid package name or package not found: ${chalk.yellow(pkg)}`,
		);
		return;
	}

	const tomlRes = await axios.get(
		`https://raw.githubusercontent.com/${pkg}/${repoRes.data.default_branch}/hammer.toml`,
	);
	if (tomlRes.status !== 200) {
		pogger.error(
			`Invalid package name or package not found: ${chalk.yellow(pkg)}`,
		);
		return;
	}

	const toml = parse(tomlRes.data);

	pogger.event(
		`${chalk.yellow(pkg)}@${chalk.green(
			toml.version,
		)} found! Installing...`,
	);

	const downloadRes = await axios.get(
		`https://github.com/${pkg}/archive/refs/heads/${repoRes.data.default_branch}.zip`,
		{
			responseType: "stream",
		},
	);

	if (downloadRes.status !== 200) {
		pogger.error(
			`An error occured while downloading ${chalk.yellow(pkg)}:`,
			downloadRes.status,
			downloadRes.statusText,
		);
		return;
	}

	createModuleFolder(owner);

	let status = await installFile(downloadRes.data, owner, repo);

	if (!status) {
		pogger.error(
			`An error occured while downloading ${chalk.yellow(
				pkg,
			)}, please try again.`,
		);
		return;
	}

	new AdmZip(
		join(process.cwd(), "hammer_modules", owner, `${repo}.zip`),
	).extractAllTo(
		join(process.cwd(), "hammer_modules", owner, "_", repo),
		true,
	);

	rmSync(join(process.cwd(), "hammer_modules", owner, `${repo}.zip`), {
		recursive: true,
		force: true,
	});

	const mainFolder = readdirSync(
		join(process.cwd(), "hammer_modules", owner, "_", repo),
	)[0];

	status = await move(
		join(process.cwd(), "hammer_modules", owner, "_", repo, mainFolder),
		join(process.cwd(), "hammer_modules", owner, repo),
	);

	if (!status) {
		pogger.error(
			`An error occured while installing ${chalk.yellow(
				pkg,
			)}, please try again.`,
		);
		return;
	}

	rmSync(join(process.cwd(), "hammer_modules", owner, "_"), {
		recursive: true,
		force: true,
	});

	pogger.success(`${chalk.yellow(pkg)} installed successfully!`);

	if ((toml.dependencies as string[])?.length > 0) {
		for (const dependency of toml.dependencies as string[]) {
			if (
				!dependencies.includes(dependency) &&
				!packages.includes(dependency)
			)
				dependencies.push(dependency);
		}
	}

	if ((toml.node_dependencies as string[])?.length > 0) {
		for (const dependency of toml.node_dependencies as string[]) {
			if (!nodeDepencencies.includes(dependency))
				nodeDepencencies.push(dependency);
		}
	}
}

export async function move(source: string, dest: string): Promise<boolean> {
	return new Promise((resolve) => {
		const isExists = existsSync(dest);
		if (isExists)
			rmSync(dest, {
				recursive: true,
				force: true,
			});

		mv(
			source,
			dest,
			{
				mkdirp: true,
			},
			(err) => {
				if (err) {
					pogger.error(err);
					resolve(false);
				}
				resolve(true);
			},
		);
	});
}

export async function installFile(
	data: Stream,
	owner: string,
	repo: string,
): Promise<boolean> {
	return new Promise((resolve) => {
		const writer = createWriteStream(
			join(process.cwd(), "hammer_modules", owner, `${repo}.zip`),
		);
		data.pipe(writer);
		writer.on("finish", () => resolve(true));
		writer.on("error", (e) => {
			pogger.error(e);
			resolve(false);
		});
	});
}
