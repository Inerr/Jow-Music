"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.installFile = exports.move = exports.installPackage = exports.createMainFile = exports.createModulesFolder = exports.createModuleFolder = exports.checkIfProjectExists = exports.waitUntilGetAnswer = exports.input = exports.createDeclarationFile = exports.octokit = void 0;
// TODO: Use @hammerhq/logger (hammer_modules) when cli finished
const pogger = __importStar(require("pogger"));
const adm_zip_1 = __importDefault(require("adm-zip"));
const chalk_1 = __importDefault(require("chalk"));
const fs_1 = require("fs");
const mv_1 = __importDefault(require("mv"));
const path_1 = require("path");
const readline_1 = __importDefault(require("readline"));
const axios_1 = __importDefault(require("axios"));
const toml_1 = require("@iarna/toml");
const octokit_1 = require("octokit");
exports.octokit = new octokit_1.Octokit();
const createDeclarationFile = () => {
    if (!checkIfProjectExists())
        return;
    createModulesFolder();
    const modules = [];
    const authors = (0, fs_1.readdirSync)((0, path_1.join)(process.cwd(), "hammer_modules"));
    if (authors.length) {
        for (const author of authors) {
            const repos = (0, fs_1.readdirSync)((0, path_1.join)(process.cwd(), "hammer_modules", author));
            if (repos.length) {
                for (const repo of repos) {
                    if ((0, fs_1.existsSync)((0, path_1.join)(process.cwd(), "hammer_modules", author, repo, "hammer.toml")))
                        modules.push(`${author}/${repo}`);
                }
            }
        }
    }
    const typingsFile = `export declare const include: <T extends ModuleName>(module: string) => IncludeType<T>;

export type ModuleName = ${modules.length
        ? modules.map((module) => `"${module}"`).join(" | ")
        : "never"};

export type IncludeType<T> = 
    ${modules.length
        ? `${modules
            .map((module) => `T extends "${module}" ? typeof import(${JSON.stringify((0, path_1.join)(process.cwd(), "hammer_modules", module, "hammer", "main"))})`)
            .join(" | ")} : never`
        : "never"}
`;
    (0, fs_1.writeFileSync)((0, path_1.join)(__dirname, "index.d.ts"), typingsFile);
};
exports.createDeclarationFile = createDeclarationFile;
function input(query) {
    const rl = readline_1.default.createInterface({
        input: process.stdin,
        output: process.stdout,
    });
    return new Promise((resolve) => rl.question(`${pogger.utils.generateDate()} ${pogger.utils.icons.logIcon} [HAMMER]: ${query} `, (ans) => {
        rl.close();
        resolve(ans);
    }));
}
exports.input = input;
function waitUntilGetAnswer(query) {
    return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
        let answer = "";
        while (!answer) {
            answer = yield input(query);
        }
        resolve(answer);
    }));
}
exports.waitUntilGetAnswer = waitUntilGetAnswer;
function checkIfProjectExists() {
    const isExists = (0, fs_1.existsSync)((0, path_1.join)(process.cwd(), "hammer.toml"));
    if (isExists) {
        return true;
    }
    pogger.error(`There is no Hammer project here. ${chalk_1.default.green("Create a Hammer project")} using ${chalk_1.default.yellow("hammer init")} command.`);
    return false;
}
exports.checkIfProjectExists = checkIfProjectExists;
function createModuleFolder(module) {
    let mkdir = true;
    if ((0, fs_1.existsSync)((0, path_1.join)(process.cwd(), "hammer_modules", module))) {
        const stats = (0, fs_1.statSync)((0, path_1.join)(process.cwd(), "hammer_modules", module));
        if (stats.isDirectory())
            mkdir = false;
    }
    if (mkdir)
        (0, fs_1.mkdirSync)((0, path_1.join)(process.cwd(), "hammer_modules", module));
}
exports.createModuleFolder = createModuleFolder;
function createModulesFolder() {
    let mkdir = true;
    if ((0, fs_1.existsSync)((0, path_1.join)(process.cwd(), "hammer_modules"))) {
        const stats = (0, fs_1.statSync)((0, path_1.join)(process.cwd(), "hammer_modules"));
        if (stats.isDirectory())
            mkdir = false;
    }
    if (mkdir)
        (0, fs_1.mkdirSync)((0, path_1.join)(process.cwd(), "hammer_modules"));
}
exports.createModulesFolder = createModulesFolder;
function createMainFile() {
    let mkdir = true;
    if ((0, fs_1.existsSync)((0, path_1.join)(process.cwd(), "hammer"))) {
        const stats = (0, fs_1.statSync)((0, path_1.join)(process.cwd(), "hammer"));
        if (stats.isDirectory())
            mkdir = false;
    }
    if (mkdir)
        (0, fs_1.mkdirSync)((0, path_1.join)(process.cwd(), "hammer"));
    let write = true;
    if ((0, fs_1.existsSync)((0, path_1.join)(process.cwd(), "hammer", "main.js"))) {
        const stats = (0, fs_1.statSync)((0, path_1.join)(process.cwd(), "hammer", "main.js"));
        if (stats.isFile())
            write = false;
    }
    if (write)
        (0, fs_1.writeFileSync)((0, path_1.join)(process.cwd(), "hammer", "main.js"), "module.exports.test = () => console.log('test');");
}
exports.createMainFile = createMainFile;
function installPackage(pkg, dependencies, nodeDepencencies, packages) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        pogger.info(`Installing ${chalk_1.default.yellow(pkg)}...`);
        const [owner, repo] = pkg.split("/");
        if (!owner || !repo) {
            pogger.error(`Invalid package name: ${chalk_1.default.yellow(pkg)}`);
            return;
        }
        const repoRes = yield exports.octokit.rest.repos.get({
            repo,
            owner,
        });
        if (repoRes.status != 200) {
            pogger.error(`Invalid package name or package not found: ${chalk_1.default.yellow(pkg)}`);
            return;
        }
        const tomlRes = yield axios_1.default.get(`https://raw.githubusercontent.com/${pkg}/${repoRes.data.default_branch}/hammer.toml`);
        if (tomlRes.status !== 200) {
            pogger.error(`Invalid package name or package not found: ${chalk_1.default.yellow(pkg)}`);
            return;
        }
        const toml = (0, toml_1.parse)(tomlRes.data);
        pogger.event(`${chalk_1.default.yellow(pkg)}@${chalk_1.default.green(toml.version)} found! Installing...`);
        const downloadRes = yield axios_1.default.get(`https://github.com/${pkg}/archive/refs/heads/${repoRes.data.default_branch}.zip`, {
            responseType: "stream",
        });
        if (downloadRes.status !== 200) {
            pogger.error(`An error occured while downloading ${chalk_1.default.yellow(pkg)}:`, downloadRes.status, downloadRes.statusText);
            return;
        }
        createModuleFolder(owner);
        let status = yield installFile(downloadRes.data, owner, repo);
        if (!status) {
            pogger.error(`An error occured while downloading ${chalk_1.default.yellow(pkg)}, please try again.`);
            return;
        }
        new adm_zip_1.default((0, path_1.join)(process.cwd(), "hammer_modules", owner, `${repo}.zip`)).extractAllTo((0, path_1.join)(process.cwd(), "hammer_modules", owner, "_", repo), true);
        (0, fs_1.rmSync)((0, path_1.join)(process.cwd(), "hammer_modules", owner, `${repo}.zip`), {
            recursive: true,
            force: true,
        });
        const mainFolder = (0, fs_1.readdirSync)((0, path_1.join)(process.cwd(), "hammer_modules", owner, "_", repo))[0];
        status = yield move((0, path_1.join)(process.cwd(), "hammer_modules", owner, "_", repo, mainFolder), (0, path_1.join)(process.cwd(), "hammer_modules", owner, repo));
        if (!status) {
            pogger.error(`An error occured while installing ${chalk_1.default.yellow(pkg)}, please try again.`);
            return;
        }
        (0, fs_1.rmSync)((0, path_1.join)(process.cwd(), "hammer_modules", owner, "_"), {
            recursive: true,
            force: true,
        });
        pogger.success(`${chalk_1.default.yellow(pkg)} installed successfully!`);
        if (((_a = toml.dependencies) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            for (const dependency of toml.dependencies) {
                if (!dependencies.includes(dependency) &&
                    !packages.includes(dependency))
                    dependencies.push(dependency);
            }
        }
        if (((_b = toml.node_dependencies) === null || _b === void 0 ? void 0 : _b.length) > 0) {
            for (const dependency of toml.node_dependencies) {
                if (!nodeDepencencies.includes(dependency))
                    nodeDepencencies.push(dependency);
            }
        }
    });
}
exports.installPackage = installPackage;
function move(source, dest) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve) => {
            const isExists = (0, fs_1.existsSync)(dest);
            if (isExists)
                (0, fs_1.rmSync)(dest, {
                    recursive: true,
                    force: true,
                });
            (0, mv_1.default)(source, dest, {
                mkdirp: true,
            }, (err) => {
                if (err) {
                    pogger.error(err);
                    resolve(false);
                }
                resolve(true);
            });
        });
    });
}
exports.move = move;
function installFile(data, owner, repo) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve) => {
            const writer = (0, fs_1.createWriteStream)((0, path_1.join)(process.cwd(), "hammer_modules", owner, `${repo}.zip`));
            data.pipe(writer);
            writer.on("finish", () => resolve(true));
            writer.on("error", (e) => {
                pogger.error(e);
                resolve(false);
            });
        });
    });
}
exports.installFile = installFile;
